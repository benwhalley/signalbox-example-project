"""Forms for the Ask application"""
import os
from django.db import IntegrityError
from reversion import revision
from ask.models import Question, ChoiceSet, Instrument
from signalbox.models import Answer
from django.conf import settings
import floppyforms as forms
from signalbox.models.listeners import user_input_received
from ask.models.fields import FIELD_NAMES


class PageForm(forms.Form):
    """Dynamically generated form, from the list of questions in **kwargs."""

    def save(self, *args, **kwargs):
        reply = kwargs.pop('reply')
        for key, val in self.cleaned_data.iteritems():
            save_question_response(val, reply, variable_name=key)
        user_input_received.send(self, reply=reply)
        return True

    def __init__(self, *args, **kwargs):
        """Overridden to dynamically create form."""

        reply = kwargs.pop('reply')
        page = kwargs.pop('page')
        request = kwargs.pop('request')
        questions_to_show = page.questions_to_show(reply)
        super(PageForm, self).__init__(*args, **kwargs)

        for i in questions_to_show:
            self.fields[i.question.variable_name] = i.question.field_class()(
                                                        questioninaskpage=i,
                                                        reply=reply,
                                                        request=request)

        self.conditional_questions = [{'question': i.question, 'showif': i.showif}
            for i in page.questions_to_show()]
        self.page = page

        self.fields['page_id'] = forms.IntegerField(required=True,
                                                        widget=forms.HiddenInput, initial=page.id)


@revision.create_on_success
def save_question_response(response, reply, question=None, variable_name=None):
    """Saves response as an Answer, unique within this Reply.

    If a previous answer to the question has been given within this Reply then
    the previous answer will be updated with a new Revision.
    """

    if variable_name:
        try:
            question = Question.objects.get(variable_name=variable_name)
            field_class = question.field_class()
            answer, created = Answer.objects.get_or_create(question=question,
                reply=reply)
            answer = field_class.save_answer(response, answer)

        except Question.DoesNotExist:
            # e.g. page_id's
            answer, created = Answer.objects.get_or_create(
                            other_variable_name=variable_name,
                            reply=reply,)
            answer.answer = response


    if created:
        revision.comment = "New answers saved"
    else:
        revision.comment = "Existing answers changed"

    answer.save()
    return answer



class BulkAddQuestionsForm(forms.Form):

    questions = forms.CharField(required=True, widget=forms.widgets.Textarea(attrs={'cols': '80'}),
        help_text="Add questions, one per line")
    variable_names = forms.CharField(required=False, widget=forms.widgets.Textarea(attrs={'cols': '20', 'class': 'varnames'}),
        help_text="""Optional: Include names for the questions specified above.
        If none provided names will be auto-generated by replacing spaces from the question wording with underscores and removing common words. The resulting names should be valid stata variables.""")
    variable_prefix = forms.SlugField(required=True, max_length=6,
        help_text="Prefix to be used for all questions (remember to add an underscore if you wanted one).")
    q_type = forms.ChoiceField(required=True, initial="likert", choices=[(i, i.upper()) for i in FIELD_NAMES])
    choiceset = forms.ModelChoiceField(required=False, queryset=ChoiceSet.objects.all())
    add_to_instrument = forms.ModelChoiceField(required=False, queryset=Instrument.objects.all())

    def clean(self):
        cleaned_data = self.cleaned_data
        prefix = cleaned_data.get('variable_prefix', "")
        names = cleaned_data.get('variable_names', "")
        questions = cleaned_data['questions']

        names, prefix, questions = [en.smart_unicode(i, encoding='utf-8', strings_only=False, errors='strict')
            for i in [names, prefix, questions]]

        questions = questions.split("\r\n")

        if names:
            names = en.smart_unicode(names, encoding='utf-8', strings_only=False, errors='strict')
            names = names.split("\r\n")
            if len(names) != len(questions):
                raise forms.ValidationError("Number of questions and variable names doesn't match.")
            var_names = [prefix + n for n in names]
            var_names = [valid.is_lower(i) for i in var_names]
            var_names = [valid.first_char_is_alpha(i) for i in var_names]
            var_names = [valid.illegal_characters(i) for i in var_names]
            var_names = [valid.less_than_n_chars(i, 32) for i in var_names]
            var_names = [statify(i) for i in var_names]

        else:
            var_names = [statify(n, prefix) for n in questions]

        cleaned_data['variable_names'] = var_names

        return cleaned_data
